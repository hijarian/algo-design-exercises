% chktex-file 19 chktex-file 1
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}

\usepackage{amsmath}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{algpseudocode}
\usepackage{listingsutf8}

\begin{document}

\section{Глава 1}

\subsection{Поиск контрпримеров}

\subsubsection{\#1}

\textbf{Условие.}
Докажите, что значение \(a + b\) может быть меньшим, чем значение \(\min(a, b)\).


Допустим:
\begin{equation}
    a = 0, b=-1
\end{equation}

Тогда:
\begin{eqnarray}
    0 + (-1) = &-1& \\
    &-1& < 0 = \min(0, 1)
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#2}

\textbf{Условие.}
Докажите, что значение \(a \times b\) может быть меньшим, чем значение \(\min(a, b)\).

Допустим:
\begin{equation}
    a = \frac{1}{2}, b = \frac{1}{4}
\end{equation}

Тогда:
\begin{eqnarray}
    \frac{1}{2} \times \frac{1}{4} =  \frac{1}{8} & \\
    & \frac{1}{8} < \min(\frac{1}{2}, \frac{1}{4}) = \frac{1}{4}
\end{eqnarray}

Что и требовалось доказать.


\subsubsection{\#3}

\textbf{Условие.}
Начертите сеть дорог с двумя точками \(a\) и \(b\), такими, что маршрут между ними,
преодолеваемый за кратчайшее время, не является самым коротким.

\begin{tikzpicture}
    \node (a)     [circle, draw] {a};
    \node (b)     [right of=a] [circle, draw] {b};
    \node (node1) [below of=a] [circle, draw] {1};
    \node (node2) [below of=b] [circle, draw] {2};
    \draw (a) to node [auto,swap]{10} (b);
    \draw (a) to node [auto,swap]{1} (node1);
    \draw (node1) to node [auto,swap]{1} (node2);
    \draw (node2) to node [auto,swap]{1} (b);
\end{tikzpicture}

Цена маршрута <<a,1,2,b>> равна 3, а цена маршрута <<a,b>> равна 10.
То есть, маршрут, проходящий через больше точек, более длинный, преодолевается за меньшее время.
Что и требовалось доказать.

\subsubsection{\#4}

\textbf{Условие.}
Начертите сеть дорог с двумя точками \(a\) и \(b\),
самый короткий маршрут между которыми не является маршрутом с наименьшим числом поворотов.

\begin{tikzpicture}
    \node (a) [circle,draw] {a};
    \node (k) [below of=a] [circle,draw] {k};
    \node (l) [below of=k] [circle,draw] {l};
    \node (m) [below of=l] [circle,draw] {m};
    \node (n) [right of=a] [circle,draw] {n};
    \node (o) [below of=n, right of=b] [circle,draw] {o};
    \node (b) [below of=m]  [circle,draw] {b};
    \draw (a) -- (n);
    \draw (a) -- (k);
    \draw (k) -- (l);
    \draw (l) -- (m);
    \draw (m) -- (b);
    \draw (b) -- (o);
    \draw (o) -- (n);
\end{tikzpicture}

В данной сети дорог кратчайший маршрут от \(a\) до \(b\) это \(anob\), в котором 3 ребра,
но два поворота.
Однако, маршрут без поворотов вообще, \(aklmb\) не самый короткий --- в нём 4 ребра.
Что и требовалось доказать.

\subsubsection{\#5}

\textbf{Условие.}
Задача о рюкзаке: имея множество целых чисел \(S = \{s_1, s_2, \ldots, s_n \}\) и целевое число \(T\),
найти такое подмножество множества \(S\), сумма которого в точности равна \(T\).
Например, множество \(S = \{1, 2, 5, 9, 10\}\), содержит такое подмножество, сумма элементов которого равна T = 22,
но не T = 23.

Найти контрпримеры для каждого из следующих алгоритмов решения задачи о рюкзаке,
т. е., нужно найти такое множество S и число T, при которых подмножество,
выбранное с помощью данного алгоритма, не до конца заполняет рюкзак,
хотя правильное решение и существует:

\begin{itemize}
    \item вкладывать элементы множества S в рюкзак в порядке слева направо, если они подходят (т. е., алгоритм <<первый подходящий>>);
    \item вкладывать элементы множества S в рюкзак в порядке от наименьшего до наибольшего
          (т. е., используя алгоритм <<первый лучший>>);
    \item вкладывать элементы множества S в рюкзак в порядке от наибольшего до наименьшего.
\end{itemize}

\textbf{Первый подходящий.}
\(T = 10, S = \{9, 2, 2, 2, 2, 2\}\)

\textbf{Первый лучший.}
\(T = 6, S = \{1, 2, 5, 4\}\)

\textbf{От самого большого.}
\(T = 6, S = \{3, 2, 5, 4\}\)

\subsubsection{\#6}

\textbf{Условие.}
Задача о покрытии множества: имея семейство подмножеств \(S_1, \ldots, S_m\) универсального
множества \(U = \{1, \ldots, n\}\), найдите семейство подмножеств \(T \subset S\) 
наименьшей мощности, чтобы \(\bigcup_{t_i} \in T^{t_i} = U\).
Например, для семейства подмножеств \(S_1 = \{1, 3, 5\}\), \(S_2 = \{2, 4\}\), \(S_3 = \{1, 4\}\),
\(S_5 = \{2,5\}\) покрытием множества будет семейство подмножеств \(S_1\) и \(S_2\).

Приведите контрпример для следующего алгоритма: выбираем самое мощное подмножество для покрытия,
после чего удаляем все его элементы из универсального множества; повторяем добавление подмножества,
содержащего наибольшее количество неохваченных элементов, пока все элементы не будут покрыты.

\begin{align}
    S_1 &= \{1, 3, 5, 7, 9\}\\
    S_2 &= \{1, 2\}\\
    S_3 &= \{3, 4\}\\
    S_4 &= \{5, 6\}\\
    S_5 &= \{7, 8\}\\
    S_6 &= \{9, 10\}
\end{align}

Наилучшее покрытие это \(S_2 \cup S_3 \cup S_4 \cup S_5 \cup S_6\),
но жадный алгоритм вначале выберет \(S_1\) как самое мощное подмножество,
а потом не останется ничего другого, как добавлять все остальные подмножества,
то есть, в итоге алгоритм выберет все исходные подмножества в качестве результата работы, \(T = S\).

\subsection{Доказательство правильности}

\subsubsection{\#7}

\textbf{Условие.}
Докажите правильность следующего рекурсивного алгоритма умножения двух натуральных чисел
для всех целочисленных констант \(c \geqslant 2\):

\begin{algorithmic}[1]
\Function{multiply}{$y,z$}
    \If{$z = 0$}
        \State \Return $0$
    \Else
        \State \Return $multiply(cy, \lfloor z/c \rfloor) + y * (z \mod c)$
    \EndIf
\EndFunction
\end{algorithmic}
    
Вычислим результат работы multiply на каком-нибудь простом примере:

\begin{eqnarray}
&&c = 2, y = 2, z = 3 \\
&  & multiply(2, 3) \\
&= & multiply(2*2, \lfloor 3/2 \rfloor) + 2 * (3 \mod 2) \\
&= & multiply(4, 1) + 2 * 1 \\
&= & multiply(4, 1) + 2 \\
&= & multiply(4 * 2, \lfloor 1 /2 \rfloor) + 4 * (1 \mod 2) + 2 \\
&= & multiply(8, 0) + 4 * 1 + 2 \\
&= & 0 + 4 + 2 \\
&= & 6
\end{eqnarray}

Пусть $z = 0$.
Тогда $multiply(y, z) = 0$.

Допустим теперь, что алгоритм правильный, то есть \(multiply(y, z) = yz\) при:

\begin{eqnarray}
    z \leqslant n\\
    y \geqslant 1\\
    c \geqslant 2
\end{eqnarray}

Теперь докажем, что \(multiply(y, n+1) = y(n+1)\).

\begin{eqnarray}
    &&mutiply(y, n+1) =\\
    &&multiply(y * c, \lfloor \frac{n+1}{c} \rfloor) + y * ((n+1) \mod c) =\\
    &&y*c*\lfloor \frac{n+1}{c} \rfloor + y*((n+1) \mod c) =\\
    &&y*(c * \lfloor \frac{n+1}{c} \rfloor + (n+1) \mod c) \label{FinalEquationBeforeSimplification}
\end{eqnarray}

Теперь докажем, что \(c * \lfloor \frac{n+1}{c} \rfloor + (n+1) \mod c) = n+1\).

\begin{eqnarray}
    &&n+1 \equiv z \\
    &&c\lfloor \frac{z}{c} \rfloor + z \mod c = z \label{RestoringDivision}
\end{eqnarray}

\(z/c\) в случае деления произвольных натуральных чисел --- операция с остатком.
\(\lfloor z/c \rfloor\) же избавляется от этого остатка.

В то же время, \(z \mod c\) это операция получения \textit{остатка от деления} \(z\) на \(c\).

Формула \eqref{RestoringDivision} может использоваться как есть,
потому что следует из определения операций, которые в ней используются.

Если мы умножим \(c\) на операцию, убирающую остаток от деления \(z\) на \(c\),
то получим как бы <<восстановленную>> \(z\) без остатка после деления.

\begin{equation}
    3 \times \lfloor \frac{10}{3} \rfloor = 3 \times 3 = 9
\end{equation}

Но если мы потом прибавим буквально остаток от этого же деления, мы получим исходное число!

\begin{equation}
    10 \mod 3 = 1
\end{equation}

А \(9 + 1 = 10\), как и следует из объяснения выше.

Таким образом, из \eqref{RestoringDivision} и \eqref{FinalEquationBeforeSimplification} следует:

\begin{eqnarray}
    && y \times (c \times \lfloor \frac{n+1}{c} \rfloor + (n+1) \mod c) = y \times (n + 1)\\
    && \Rightarrow multiply(y, n+1) = y \times (n + 1)
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#8}

\textbf{Условие.}
Докажите правильность следующего алгоритма вычисления полинома \(P(x) = a_nx^n + a_{n-1}x^{n-1} + \ldots + a_1x^ + a_0\):

\begin{algorithmic}[1]
    \Function{horner}{$A,x$}
        \State $p = A_n$
        \For{$i \gets n-1, 0$}
            \State $p = p \times x + A_i$
        \EndFor
        \State \Return $p$
    \EndFunction
\end{algorithmic}

Пусть \(n = 0\).
Тогда цикл не выполнится ни разу и результатом будет \(A_0\).

Пусть \(n = 1\).
Тогда:

\begin{eqnarray}
    &&p = A_1\\
    &i = 0: &p = A_1 \times x + A_0
\end{eqnarray}

Пусть \(n = 2\).
Тогда:

\begin{eqnarray}
    &&p = A_2\\
    &i = 1: &p = A_2 \times x + A_1\\
    &i = 0: &p = (A_2 \times x + A_1) \times x + A_0 = A_2 \times x^2 + A_1 \times x + A_0
\end{eqnarray}

Допустим, что алгоритм правильный при любых \(n\).
Посмотрим, что происходит при \(n+1\):

\begin{eqnarray}
    &&p = A_{n+1}\\
    &i = n: &p = A_{n+1} \times x + A_{n}\\
    &i = n-1: &p = (A_{n+1} \times x + A_{n}) \times x + A_{n-1}\\
    & \ldots &\\
    &i = n-n = 0: &p = A_{n+1}x^{n+1} + A_nx^n + A_{n-1}x^{n-1} + \ldots + A_{n-n}
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#9}

\textbf{Условие.}
Докажите правильность следующего алгоритма сортировки:

\begin{lstlisting}
    function bubblesort(A: list[1...n])
        var int i,j
        for i from n to 1
            for j from 1 to i - 1
                if (A[j] > A[j+1])
                    swap A[j] and A[j + 1]
\end{lstlisting}

Пусть \(n = 2\).
Тогда:

\begin{eqnarray}
    &i = 2, j = 1:& A[1] > A[2] ? swap : keep
\end{eqnarray}

Пусть алгоритм может отсортировать любой массив длиной \(n\).
Может ли он отсортировать массив длиной \(n+1\)?

Передача в этот алгоритм массив длиной \(n+1\) эквивалентна замене его на следующий код:

\begin{lstlisting}
    function bubblesort(A: list[1...n+1])
        var int i,j
        for j from 1 to n + 1 - 1
            if (A[j] > A[j + 1])
                swap A[j] and A[j + 1]
        for i from n to 1
            for j from 1 to i - 1
                if (A[j] > A[j+1])
                    swap A[j] and A[j + 1]        
\end{lstlisting}

По индукции мы допустили, что основная пара вложенных циклов действительно отсортирует
все элементы от 1 до \(n\).

Мы же добавили в код ещё один цикл:

\begin{lstlisting}
    for j from 1 to n
        if (A[j] > A[j + 1])
            swap A[j] and A[j + 1]
\end{lstlisting}

Этот цикл проверит два новых элемента: \texttt{A[n]} и \texttt{A[n+1]}, последние в списке.
Элемент \texttt{A[n+1]} идёт после отсортированных элементов \texttt{A[1] ... A[n]}.
Если они не в правильном порядке, он их поменяет местами, в точности как случай когда \(n = 2\).

Таким образом, этот алгоритм действительно сортирует массивы любой длины.

\subsection{Математическая индукция}

\subsubsection{\#10}

\textbf{Условие.}
Докажите, что:

\begin{equation}
    \sum_{i=1}^ni=\frac{n(n+1)}{2}
\end{equation}

для \(n \geqslant 0\).

По индукции, пусть \(n=1\):
\begin{eqnarray}
    1 &=& \frac{1\times(1 + 1)}{2}\\
    1 &=& \frac{1 \times 2}{2}\\
    1 &=& 1
\end{eqnarray}

Пусть верно для \(n\).
Вычислим для \(n+1\):

\begin{eqnarray}
    1 + 2 + \ldots + n + (n + 1) &=& \frac{(n+1)(n+2)}{2}\\
    \frac{n(n+1)}{2} + n + 1 &=& \frac{(n+1)(n+2)}{2}\\
    n(n + 1) + 2n + 2 = (n + 1)(n + 2)\\
    n^2 + n + 2n + 2 = n^2 + n + 2n + 2
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#11}

\textbf{Условие.}
Докажите, что:

\begin{equation}
    \sum_{i=1}^n i^2 = n(n+1)(2n+1)/6, n \geqslant 0
\end{equation}

Пусть \(n = 1\), тогда:

\begin{eqnarray}
    1^2 &=& \frac{1 \times (1 + 1)(2 \times 1 + 1)}{6}\\
    1 &=& \frac{6}{6} \\
    1 &=& 1
\end{eqnarray}

Теперь пусть формула верна для любых \(n\).
Вычислим для \(n+1\):

\begin{eqnarray}
    \sum_{i=1}^ni^2 + (n+1)^2 &=& \frac{(n+1)(n+1+1)(2 \times (n+1) + 1)}{6}\\
    \frac{n(n+1)(2n+1)}{6} + (n+1)^2 &=& \frac{(n+1)(n+2)(2n + 3)}{6}\\
    n(n+1)(2n+1) + 6n^2 + 12n + 6 &=& (n+1)(n+2)(2n+3)\\
    (n^2 + n)(2n+1) + 6n^2 + 12n + 6 &=& (n^2 + n + 2n + 2)(2n + 3)\\
    2n^3 + 2n^2 + n^2 + n + 6n^2 + 12n + 6 &=& 2n^3 + 2n^2 + 4n^2 + 4n + 3n^2 + 3n + 6n + 6\\
    2n^3 + 9n^2 + 13n + 6 &=& 2n^3 + 9n^2 + 13n + 6
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#12}

\textbf{Условие.}
Докажите, что:

\begin{equation}
    \sum_{i=1}^n i^3 = \frac{n^2(n+1)^2}{4}, n \geqslant 0
\end{equation}

Пусть \(n = 1\).

\begin{eqnarray}
    1 &=& \frac{1 \times 2^2}{4}\\
    1 &=& 4/4\\
    1 &=& 1
\end{eqnarray}

Теперь пусть формула верна для любых \(n\).
Вычислим для \(n+1\):

\begin{eqnarray}
    \sum_{i=1}^n i^3 + (n+1)^3 &=& \frac{(n+1)^2(n+2)^2}{4}\\
    \frac{n^2(n+1)^2}{4} + (n + 1)^3 &=& \frac{(n+1)^2(n+2)^2}{4}\\
    n^2(n+1)^2 + 4(n+1)(n+1)^2 &=& (n+1)^2(n+2)^2\\
    (n+1)^2(n^2 + 4n + 4) &=& (n+1)^2(n+2)^2\\
    n^2 + 4n + 4 &=& (n+2)^2\\
    n^2 + 4n + 4 &=& n^2 + 4n + 4 
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#13}

\textbf{Условие.}
Докажите, что:

\begin{equation}
    \sum_{i=1}^n i(i+1)(i+2) = \frac{n(n+1)(n+2)(n+3)}{4}, n \geqslant 0
\end{equation}

Пусть \(n = 1\).

\begin{eqnarray}
    2 \times 3 &=& \frac{2 \times 3 \times 4}{4}\\
    6 &=& 6
\end{eqnarray}

Теперь пусть формула верна для любых \(n\).
Вычислим для \(n+1\):

\begin{eqnarray}
    \sum_{i=1}^n i(i+1)(i+2) + (n+1)(n+2)(n+3) &=& \frac{(n+1)(n+2)(n+3)(n+4)}{4}\\
    \frac{n(n+1)(n+2)(n+3)}{4} + (n+1)(n+2)(n+3) &=& \frac{(n+1)(n+2)(n+3)(n+4)}{4}\\
    n(n+1)(n+2)(n+3) + 4(n+1)(n+2)(n+3) &=& (n+1)(n+2)(n+3)(n+4)\\
    n+4 &=& n+4
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#14}

\textbf{Условие.}
Докажите, что:

\begin{equation}
    \sum_{i=0}^n a^i = \frac{a^{n+1} - 1}{a - 1}, n \geqslant 1, a \neq 1
\end{equation}

Пусть \(n=1\). Тогда:

\begin{eqnarray}
    a^0 + a^1 &=& \frac{a^2 - 1}{a-1}\\
    (a - 1)(a + 1) &=& a^2 - 1\\
    a^2 -a + a -1 &=& a^2 - 1\\
    a^2 - 1 &=& a^2 - 1
\end{eqnarray}

Теперь пусть формула верна для любых \(n\).
Вычислим для \(n+1\):

\begin{eqnarray}
    \sum_{i=0}^n a^i + a^{n+1} &=& \frac{a^{n+2} - 1}{a - 1}\\
    \frac{a^{n+1} - 1}{a-1} + a^{n+1} &=& \frac{a^{n+2} - 1}{a - 1}\\
    a^{n+1} - 1 + a^{n+1}(a - 1) &=& a^{n+2} - 1\\
    a^{n+1} - 1 + a^{n+2} - a^{n+1} &=& a^{n+2} - 1\\
    a^{n+2} - 1 &=& a^{n+2} - 1
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#15}

\textbf{Условие.}
Докажите, что:

\begin{equation}
    \sum_{i=1}^n \frac{1}{i(i+1)} = \frac{n}{n + 1}, n \geqslant 0
\end{equation}

Пусть \(n=1\). Тогда:

\begin{eqnarray}
    1/2 = 1/2
\end{eqnarray}

Теперь пусть формула верна для любых \(n\).
Вычислим для \(n+1\):

\begin{eqnarray}
    \sum_{i=1}^n \frac{1}{i(i+1)} + \frac{1}{(n+1)(n+2)} &=& \frac{n + 1}{n + 2}\\
    \frac{n}{n+1} + \frac{1}{(n+1)(n+2)} &=& \frac{n+1}{n+2}\\
    \frac{n(n+2)}{(n+1)(n+2)} + \frac{1}{(n+1)(n+2)} &=& \frac{(n+1)(n+1)}{(n+1)(n+2)}\\
    \frac{n(n+2) + 1}{(n+1)(n+2)} &=& \frac{n^2 + 2n + 1}{(n+1)(n+2)}\\
    \frac{n^2 + 2n + 1}{(n+1)(n+2)} &=& \frac{n^2 + 2n + 1}{(n+1)(n+2)}
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#16}

\textbf{Условие.}
Докажите, что \(n^3 + 2n\) делится на \(3\) для \(n \geqslant 0\).

Пусть \(n = 0\).
Тогда выражение равно 0, что условно делится на 3.

Пусть выражение верно для любых \(n\).

Вычислим для \(n+1\).

\begin{align}
    (n+1)^3 + 2(n+1) =\\
    (n+1)(n^2 + 2n + 1) + 2n + 2 =\\
    n^3 + 2n^2 + n + n^2 + 2n + 1 + 2n + 2 =\\
    n^3 + 3n^2 + 5n + 3 =\\
    n^3 + 2n + 3n^2 + 3n + 3 =\\
    n^3 + 2n + 3(n^2 + n + 1) \label{SumOfDividents}
\end{align}

Представим \eqref{SumOfDividents} в виде \(A + B\), где \(A = n^3 + 2n\),
а \(B = 3(n^2 + n + 1)\).
Мы допустили по индукции, что \(A \vdots 3\).
В то же время \(B\) является произведением 3 на натуральное число больше 0,
то есть, тоже делится на 3.
По свойству делимости сумма чисел, которые делятся на 3, делится на 3.

Что и требовалось доказать.

\subsubsection{\#17}

\textbf{Условие.}
Докажите, что дерево с \(n\) вершинами имеет в точности \(n - 1\) рёбер.

Если \(n = 0\) то задача не имеет смысла.
Если \(n = 1\) то дерево с одной вершиной не имеет рёбер, то есть, верно.
Если \(n = 2\) то между двумя вершинами можно провести только одно ребро, то есть, верно.

Пусть верно для всех \(n\).

Дерево с \(n+1\) вершинами это дерево с \(n\) вершинами, к которому присоединили ещё одну.
Дерево с \(n\) вершинами имеет \(n-1\) рёбер по индукции.

Так как у нас не граф, а дерево, есть только один способ добавить вершину в дерево:
соединив её ровно одним ребром с другой одной существующей вершиной в дереве.

Так как таким образом мы добавили одну вершину и одно ребро,
соотношение между количеством рёбер и количеством вершин не изменилось,
у нас всё так же ровно на одно ребро меньше, чем вершин.

Что и требовалось доказать.

\subsubsection{\#18}

\textbf{Условие.}
Докажите, что сумма кубов первых \(n\) положительных целых чисел равна квадрату суммы этих целых чисел,
т. е.,

\begin{equation}
    \sum_{i=1}^n i^3 = \left(\sum_{i=1}^n i \right)^2
\end{equation}

Ранее в задачах \#10 и \#12 были доказаны сокращённые формы записи этих сумм.
Подставим их в выражение и упростим:

\begin{eqnarray}
    \frac{n^2(n+1)^2}{4} &=& \left( \frac{n(n+1)}{2} \right)^2\\
    \frac{n^2(n+1)^2}{4} &=& \frac{n^2(n+1)^2}{4}
\end{eqnarray}

Что и требовалось доказать.

\subsection{Приблизительные подсчёты}

\subsubsection{\#19}

\textbf{Условие.}
Содержат ли все ваши книги, по крайней мере, миллион страниц?
Каково общее количество всех книг в вашей институтской библиотеке?

Типичное среднее число страниц в книгах в моей библиотеке --- 400.
Для того, чтобы достичь миллиона страниц, мне нужно иметь минимум $1000000 / 400 = 2500$ книг.
У меня точно нет 2500 книг, поэтому во всех моих книгах точно нет миллиона страниц.

В моей институтской библиотеке было не больше 20 рядов с книгами.
Каждый ряд содержал меньше шести полок с каждой стороны ряда.
Каждый ряд был длиной меньше пяти метров.
Одна книга в среднем 5 см толщиной.

Таким образом, на каждой полке меньше $5 м / 0.05 м = 100$ книг.
В каждом ряду $100 \times 6 \times 2 = 1200$ книг.

Получается, что в моей институтской библиотеке было не больше $20 \times 1200 = 24000$ книг.
Примерно 1000 книг на каждую начальную букву алфавита.

\subsubsection{\#20}

\textbf{Условие.}
Сколько слов содержит эта книга?

В русском издании этой книги ровно 720 страниц.

Одна строчка этой книги содержит 7-12 слов, считая формулы, местоимения и части слов,
перенесённые с предыдущей строчки, отдельными словами.
Возьмём в качестве среднего числа слов на строчку 10.

Число строчек на одной странице примерно 44.

Учитывая то, что в книге активно используются изображения, листинги, выносные формулы и заголовки,
уменьшим число строчек на 25\%.

Таким образом, в этой книге примерно $720 \times 44 \times 0.75 \times 10 = 7200 \times 33 = 237600$.

Удивительно, но это значит, что в этой книге примерно 240 тысяч слов!

\subsubsection{\#21}

\textbf{Условие.}
Сколько часов составляет один миллион секунд?
А сколько дней?
Выполните все необходимые вычисления в уме.

Как минимум 250 часов.

Это 10 дней и 10 часов, то есть, почти 10 с половиной дней.

\subsubsection{\#22}

\textbf{Условие.}
Сколько городов и посёлков в Соединённых Штатах?

Население Штатов $\approx 200$ миллионов человек.
В стране меньше 50 городов с населением больше миллиона человек.

Остаётся 150 миллионов населения.

Если принять размер <<города>> в 200000 человек населения, а посёлка в 10000,
и допустить, что на один город приходится пять посёлков, то получаем следующую систему уравнений:

\begin{eqnarray}
    200000x + 10000y &=& 150000000\\
    5x &=& y
\end{eqnarray}

Где $x$ это количество городов, а $y$ это количество посёлков.

Согласно моей модели, получается, что:

\begin{eqnarray}
    200000x + 10000 \times 5x &=& 150000000\\
    20x + 5x &=& 15000\\
    25x &=& 15000\\
    x &=& 600
\end{eqnarray}

Отсюда $y = 5x = 3000$.

Таким образом, согласно моей упрощённой модели распределения населения по США
у них примерно 50 городов-миллионников, 600 городов с населением в среднем 200000 человек,
и 3000 посёлков с населением в среднем 10000 человек.

Это много.

\subsubsection{\#23}

\textbf{Условие.}
Сколько кубических километров воды изливается из устья Миссисипи каждый день?
Не пользуйтесь никакой справочной информацией.
Опишите все предположения, сделанные вами для получения ответа.

Миссисипи --- широкая река.
Широкие реки должны течь медленно.

Скорость истечения воды в $m^3/day$ вычислим так.
Перемножим скорость течения воды (на поверхности) на площадь сечения реки.

Допустим, скорость течения широкой огромной реки --- как пеший человек, $5 km/h$.
Допустим, ширина устья Миссисипи --- 3 км.
Допустим, максимальная глубина 50 м.
Допустим, сечение реки это прямоугольник, то есть, площадь сечения это $3 km \times 0.05 km = 0.15 km^2$.

Тогда получается, что скорость истечения равна: 
\begin{eqnarray}
    \frac{5 km \times 0.15 km^2}{1 \times h} =\\
    \frac{0.75 km^3}{1/24 day} =\\
    0.75 \times 24 \frac{km^3}{day} =\\
    18 \frac{km^3}{day}
\end{eqnarray}    

Итого согласно моим допущениям скорость истечения воды Миссисипи равна 18 кубическим километрам
в день.

\subsubsection{\#24}

\textbf{Условие.}
В каких единицах измеряется время доступа к жёсткому диску, в миллисекундах или в микросекундах?
\textit{в миллисекундах}
Сколько времени занимает доступ к слову в оперативной памяти вашего компьютера,
больше или меньше микросекунды?
\textit{меньше, ближе к нескольким наносекундам}
Сколько инструкций может выполнить центральный процессор вашего компьютера в течение года,
если компьютер постоянно держать включённым?

Как минимум 1 терафлопс мой Intel Core i7--7700K делает, поэтому
получается 1 триллион операций в секунду.
$3600 \times 24 \times 365 = 31536000$ секунд в году.

Получается, как минимум $3.1536\times 10^{19}$ операций в год.

\subsubsection{\#25}

\textbf{Условие.}
Алгоритм сортировки выполняет сортировку 1000 элементов за 1 секунду.
Сколько времени займёт сортировка 10000 элементов,
\begin{itemize}
    \item если время исполнения алгоритма прямо пропорционально $n^2$?
    \item если время исполнения алгоритма, по грубым оценкам, пропорционально $n\log{n}$?
\end{itemize}

Если сложность алгоритма $n^2$, то увеличив количество элементов в 10 раз мы увеличили
время исполнения в $10^2 = 100$ раз.
Получается, что не одну секунду, а 100, почти две минуты.

Если время исполнения алгоритма пропорционально $n \log{n}$, то значит,
новое время исполнения равно:

\begin{eqnarray}
    \frac{10^4 \log{10^4}}{10^3 \log{10^3}} =\\
    \frac{10 \times 4}{3} =\\
    13.(3)
\end{eqnarray}

Таким образом, не 1 секунду, а 14.

\subsection{Проекты по реализации}

\subsubsection{\#26}

\textbf{Условие.}
Реализуйте два эвристических алгоритма решения задачи коммивояжёра из раздела 1.1.
Какой из них выдаёт на практике более качественные решения?
Можете ли вы предложить эвристический алгоритм, работающий лучше любого из них?

\textbf{Алгоритм 1.}

\begin{algorithmic}[1]
    \Function{NearestNeighbor}{$P$}
        \State Из множества $P$ выбираем и посещаем произвольную начальную точку $p_0$.
        \State $p = p_0$
        \State $i = 0$
        \While{Пока остаются непосещённые точки}
            \State $i = i + 1$
            \State Выбираем и посещаем непосещённую точку $p_i$, ближайшую к точке $p_{i-1}$
            \State Посещаем точку $p_i$
        \EndWhile
        \State Возвращаемся в точку $p_0$ от точки $p_{n-1}$
    \EndFunction
\end{algorithmic}

Реализация алгоритма в папке \texttt{chapter01}, проект Visual Studio 2017 \texttt{01.26.sln}

\textbf{Алгоритм 2.}

\begin{algorithmic}[1]
    \Function{ClosestPair}{$P$}
        \State Пусть $n$ --- количество точек множества $P$.
        \For{$i \gets n-1, 1$}
            \State $d = \infty$
            \For{Каждая пара точек $(s, t)$, не имеющих общих вершин цепей}
                \If{$dist(s,t) \leqslant d$}
                    \State $s_m = s$, $t_m = t$ и $d = dist(s,t)$
                \EndIf
                \State Соединяем $(s_m, t_m)$ ребром.
            \EndFor
        \EndFor
        \State Соединяем две конечные точки ребром.
    \EndFunction
\end{algorithmic}

Для реализации этих алгоритмов сделаны следующие допущения.

\begin{enumerate}
    \item Входные данные это массив координат точек на плоскости.
    \item Выходные данные это массив координат точек на плоскости в порядке их посещения.
    \item Рисовать ничего не будем.
    \item Программа будет писать результат в консоль перечислением точек одной под другой.
\end{enumerate}

\end{document}
