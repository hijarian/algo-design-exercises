% chktex-file 19 chktex-file 1
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}

\usepackage{amsmath}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{algpseudocode}
\usepackage{listingsutf8}

\begin{document}

\section{Глава 1}

\subsection{Поиск контрпримеров}

\subsubsection{\#1}

\textbf{Условие.}
Докажите, что значение \(a + b\) может быть меньшим, чем значение \(\min(a, b)\).


Допустим:
\begin{equation}
    a = 0, b=-1
\end{equation}

Тогда:
\begin{eqnarray}
    0 + (-1) = &-1& \\
    &-1& < 0 = \min(0, 1)
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#2}

\textbf{Условие.}
Докажите, что значение \(a \times b\) может быть меньшим, чем значение \(\min(a, b)\).

Допустим:
\begin{equation}
    a = \frac{1}{2}, b = \frac{1}{4}
\end{equation}

Тогда:
\begin{eqnarray}
    \frac{1}{2} \times \frac{1}{4} =  \frac{1}{8} & \\
    & \frac{1}{8} < \min(\frac{1}{2}, \frac{1}{4}) = \frac{1}{4}
\end{eqnarray}

Что и требовалось доказать.


\subsubsection{\#3}

\textbf{Условие.}
Начертите сеть дорог с двумя точками \(a\) и \(b\), такими, что маршрут между ними,
преодолеваемый за кратчайшее время, не является самым коротким.

\begin{tikzpicture}
    \node (a)     [circle, draw] {a};
    \node (b)     [right of=a] [circle, draw] {b};
    \node (node1) [below of=a] [circle, draw] {1};
    \node (node2) [below of=b] [circle, draw] {2};
    \draw (a) to node [auto,swap]{10} (b);
    \draw (a) to node [auto,swap]{1} (node1);
    \draw (node1) to node [auto,swap]{1} (node2);
    \draw (node2) to node [auto,swap]{1} (b);
\end{tikzpicture}

Цена маршрута <<a,1,2,b>> равна 3, а цена маршрута <<a,b>> равна 10.
То есть, маршрут, проходящий через больше точек, более длинный, преодолевается за меньшее время.
Что и требовалось доказать.

\subsubsection{\#4}

\textbf{Условие.}
Начертите сеть дорог с двумя точками \(a\) и \(b\),
самый короткий маршрут между которыми не является маршрутом с наименьшим числом поворотов.

\begin{tikzpicture}
    \node (a) [circle,draw] {a};
    \node (k) [below of=a] [circle,draw] {k};
    \node (l) [below of=k] [circle,draw] {l};
    \node (m) [below of=l] [circle,draw] {m};
    \node (n) [right of=a] [circle,draw] {n};
    \node (o) [below of=n, right of=b] [circle,draw] {o};
    \node (b) [below of=m]  [circle,draw] {b};
    \draw (a) -- (n);
    \draw (a) -- (k);
    \draw (k) -- (l);
    \draw (l) -- (m);
    \draw (m) -- (b);
    \draw (b) -- (o);
    \draw (o) -- (n);
\end{tikzpicture}

В данной сети дорог кратчайший маршрут от \(a\) до \(b\) это \(anob\), в котором 3 ребра,
но два поворота.
Однако, маршрут без поворотов вообще, \(aklmb\) не самый короткий --- в нём 4 ребра.
Что и требовалось доказать.

\subsubsection{\#5}

\textbf{Условие.}
Задача о рюкзаке: имея множество целых чисел \(S = \{s_1, s_2, \ldots, s_n \}\) и целевое число \(T\),
найти такое подмножество множества \(S\), сумма которого в точности равна \(T\).
Например, множество \(S = \{1, 2, 5, 9, 10\}\), содержит такое подмножество, сумма элементов которого равна T = 22,
но не T = 23.

Найти контрпримеры для каждого из следующих алгоритмов решения задачи о рюкзаке,
т. е., нужно найти такое множество S и число T, при которых подмножество,
выбранное с помощью данного алгоритма, не до конца заполняет рюкзак,
хотя правильное решение и существует:

\begin{itemize}
    \item вкладывать элементы множества S в рюкзак в порядке слева направо, если они подходят (т. е., алгоритм <<первый подходящий>>);
    \item вкладывать элементы множества S в рюкзак в порядке от наименьшего до наибольшего
          (т. е., используя алгоритм <<первый лучший>>);
    \item вкладывать элементы множества S в рюкзак в порядке от наибольшего до наименьшего.
\end{itemize}

\textbf{Первый подходящий.}
\(T = 10, S = \{9, 2, 2, 2, 2, 2\}\)

\textbf{Первый лучший.}
\(T = 6, S = \{1, 2, 5, 4\}\)

\textbf{От самого большого.}
\(T = 6, S = \{3, 2, 5, 4\}\)

\subsubsection{\#6}

\textbf{Условие.}
Задача о покрытии множества: имея семейство подмножеств \(S_1, \ldots, S_m\) универсального
множества \(U = \{1, \ldots, n\}\), найдите семейство подмножеств \(T \subset S\) 
наименьшей мощности, чтобы \(\bigcup_{t_i} \in T^{t_i} = U\).
Например, для семейства подмножеств \(S_1 = \{1, 3, 5\}\), \(S_2 = \{2, 4\}\), \(S_3 = \{1, 4\}\),
\(S_5 = \{2,5\}\) покрытием множества будет семейство подмножеств \(S_1\) и \(S_2\).

Приведите контрпример для следующего алгоритма: выбираем самое мощное подмножество для покрытия,
после чего удаляем все его элементы из универсального множества; повторяем добавление подмножества,
содержащего наибольшее количество неохваченных элементов, пока все элементы не будут покрыты.

\begin{align}
    S_1 &= \{1, 3, 5, 7, 9\}\\
    S_2 &= \{1, 2\}\\
    S_3 &= \{3, 4\}\\
    S_4 &= \{5, 6\}\\
    S_5 &= \{7, 8\}\\
    S_6 &= \{9, 10\}
\end{align}

Наилучшее покрытие это \(S_2 \cup S_3 \cup S_4 \cup S_5 \cup S_6\),
но жадный алгоритм вначале выберет \(S_1\) как самое мощное подмножество,
а потом не останется ничего другого, как добавлять все остальные подмножества,
то есть, в итоге алгоритм выберет все исходные подмножества в качестве результата работы, \(T = S\).

\subsection{Доказательство правильности}

\subsubsection{\#7}

\textbf{Условие.}
Докажите правильность следующего рекурсивного алгоритма умножения двух натуральных чисел
для всех целочисленных констант \(c \geqslant 2\):

\begin{algorithmic}[1]
\Function{multiply}{$y,z$}
    \If{$z = 0$}
        \State \Return $0$
    \Else
        \State \Return $multiply(cy, \lfloor z/c \rfloor) + y * (z \mod c)$
    \EndIf
\EndFunction
\end{algorithmic}
    
Вычислим результат работы multiply на каком-нибудь простом примере:

\begin{eqnarray}
&&c = 2, y = 2, z = 3 \\
&  & multiply(2, 3) \\
&= & multiply(2*2, \lfloor 3/2 \rfloor) + 2 * (3 \mod 2) \\
&= & multiply(4, 1) + 2 * 1 \\
&= & multiply(4, 1) + 2 \\
&= & multiply(4 * 2, \lfloor 1 /2 \rfloor) + 4 * (1 \mod 2) + 2 \\
&= & multiply(8, 0) + 4 * 1 + 2 \\
&= & 0 + 4 + 2 \\
&= & 6
\end{eqnarray}

Пусть $z = 0$.
Тогда $multiply(y, z) = 0$.

Допустим теперь, что алгоритм правильный, то есть \(multiply(y, z) = yz\) при:

\begin{eqnarray}
    z \leqslant n\\
    y \geqslant 1\\
    c \geqslant 2
\end{eqnarray}

Теперь докажем, что \(multiply(y, n+1) = y(n+1)\).

\begin{eqnarray}
    &&mutiply(y, n+1) =\\
    &&multiply(y * c, \lfloor \frac{n+1}{c} \rfloor) + y * ((n+1) \mod c) =\\
    &&y*c*\lfloor \frac{n+1}{c} \rfloor + y*((n+1) \mod c) =\\
    &&y*(c * \lfloor \frac{n+1}{c} \rfloor + (n+1) \mod c) \label{FinalEquationBeforeSimplification}
\end{eqnarray}

Теперь докажем, что \(c * \lfloor \frac{n+1}{c} \rfloor + (n+1) \mod c) = n+1\).

\begin{eqnarray}
    &&n+1 \equiv z \\
    &&c\lfloor \frac{z}{c} \rfloor + z \mod c = z \label{RestoringDivision}
\end{eqnarray}

\(z/c\) в случае деления произвольных натуральных чисел --- операция с остатком.
\(\lfloor z/c \rfloor\) же избавляется от этого остатка.

В то же время, \(z \mod c\) это операция получения \textit{остатка от деления} \(z\) на \(c\).

Формула \eqref{RestoringDivision} может использоваться как есть,
потому что следует из определения операций, которые в ней используются.

Если мы умножим \(c\) на операцию, убирающую остаток от деления \(z\) на \(c\),
то получим как бы <<восстановленную>> \(z\) без остатка после деления.

\begin{equation}
    3 \times \lfloor \frac{10}{3} \rfloor = 3 \times 3 = 9
\end{equation}

Но если мы потом прибавим буквально остаток от этого же деления, мы получим исходное число!

\begin{equation}
    10 \mod 3 = 1
\end{equation}

А \(9 + 1 = 10\), как и следует из объяснения выше.

Таким образом, из \eqref{RestoringDivision} и \eqref{FinalEquationBeforeSimplification} следует:

\begin{eqnarray}
    && y \times (c \times \lfloor \frac{n+1}{c} \rfloor + (n+1) \mod c) = y \times (n + 1)\\
    && \Rightarrow multiply(y, n+1) = y \times (n + 1)
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#8}

\textbf{Условие.}
Докажите правильность следующего алгоритма вычисления полинома \(P(x) = a_nx^n + a_{n-1}x^{n-1} + \ldots + a_1x^ + a_0\):

\begin{algorithmic}[1]
    \Function{horner}{$A,x$}
        \State $p = A_n$
        \For{$i \gets n-1, 0$}
            \State $p = p \times x + A_i$
        \EndFor
        \State \Return $p$
    \EndFunction
\end{algorithmic}

Пусть \(n = 0\).
Тогда цикл не выполнится ни разу и результатом будет \(A_0\).

Пусть \(n = 1\).
Тогда:

\begin{eqnarray}
    &&p = A_1\\
    &i = 0: &p = A_1 \times x + A_0
\end{eqnarray}

Пусть \(n = 2\).
Тогда:

\begin{eqnarray}
    &&p = A_2\\
    &i = 1: &p = A_2 \times x + A_1\\
    &i = 0: &p = (A_2 \times x + A_1) \times x + A_0 = A_2 \times x^2 + A_1 \times x + A_0
\end{eqnarray}

Допустим, что алгоритм правильный при любых \(n\).
Посмотрим, что происходит при \(n+1\):

\begin{eqnarray}
    &&p = A_{n+1}\\
    &i = n: &p = A_{n+1} \times x + A_{n}\\
    &i = n-1: &p = (A_{n+1} \times x + A_{n}) \times x + A_{n-1}\\
    & \ldots &\\
    &i = n-n = 0: &p = A_{n+1}x^{n+1} + A_nx^n + A_{n-1}x^{n-1} + \ldots + A_{n-n}
\end{eqnarray}

Что и требовалось доказать.

\subsubsection{\#9}

\textbf{Условие.}
Докажите правильность следующего алгоритма сортировки:

\begin{lstlisting}
    function bubblesort(A: list[1...n])
        var int i,j
        for i from n to 1
            for j from 1 to i - 1
                if (A[j] > A[j+1])
                    swap A[j] and A[j + 1]
\end{lstlisting}

Пусть \(n = 2\).
Тогда:

\begin{eqnarray}
    &i = 2, j = 1:& A[1] > A[2] ? swap : keep
\end{eqnarray}

Пусть алгоритм может отсортировать любой массив длиной \(n\).
Может ли он отсортировать массив длиной \(n+1\)?

Передача в этот алгоритм массив длиной \(n+1\) эквивалентна замене его на следующий код:

\begin{lstlisting}
    function bubblesort(A: list[1...n+1])
        var int i,j
        for j from 1 to n + 1 - 1
            if (A[j] > A[j + 1])
                swap A[j] and A[j + 1]
        for i from n to 1
            for j from 1 to i - 1
                if (A[j] > A[j+1])
                    swap A[j] and A[j + 1]        
\end{lstlisting}

По индукции мы допустили, что основная пара вложенных циклов действительно отсортирует
все элементы от 1 до \(n\).

Мы же добавили в код ещё один цикл:

\begin{lstlisting}
    for j from 1 to n
        if (A[j] > A[j + 1])
            swap A[j] and A[j + 1]
\end{lstlisting}

Этот цикл проверит два новых элемента: \texttt{A[n]} и \texttt{A[n+1]}, последние в списке.
Элемент \texttt{A[n+1]} идёт после отсортированных элементов \texttt{A[1] ... A[n]}.
Если они не в правильном порядке, он их поменяет местами, в точности как случай когда \(n = 2\).

Таким образом, этот алгоритм действительно сортирует массивы любой длины.

\end{document}
